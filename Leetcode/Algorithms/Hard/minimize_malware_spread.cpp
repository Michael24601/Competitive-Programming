/*
    Website: Leetcode
    Difficulty: Hard
    Language: c++
    Link: https://leetcode.com/problems/minimize-malware-spread/
*/


#include <bits/stdc++.h>

using namespace std;

class Solution {

    // Function to perform BFS on a start node, and return the component
    // it is in.
    void bfs(
        int start, const vector<vector<int>>& adjList,
        vector<int>& component,
        vector<bool>& visited
    ) {
        queue<int> q;
        q.push(start);
        component.push_back(start);
        visited[start] = true;
        
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            
            // Exploring all neighbors of the current node
            for (int neighbor : adjList[node]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push(neighbor);
                    component.push_back(neighbor);
                }
            }
        }
    }


    // Function to find all connected components in an undirected graph,
    // modified to only be used on starting nodes that are infected
    // (and have not yet been visited).
    // Also, we make it return the infected node of the largest
    // component with the smallest index.
    vector<vector<int>> findConnectedComponents(
        const vector<vector<int>>& adjList,
        const vector<int>& infected
    ) {
        int n = adjList.size();
        vector<bool> visited(n, false);
        vector<vector<int>> components;

        int maxSize = 0;
        int maxIndex;
        
        // Loop through all nodes that are infected
        for (int i = 0; i < infected.size(); i++) {
            if (!visited[infected[i]]) {
                // If the node has not been visited,
                // it's the start of a new connected component.
                vector<int> component;
                bfs(infected[i], adjList, component, visited);
                components.push_back(component);
            }
        }
        
        return components;
    }

public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // We can think of this problem in terms of a directed graph.
        // A node infects within its own connected component (area
        // with nodes that can all reach each other).
        // If a component has two infected nodes initially, removing either
        // does nothing to help lower M(initial), so we instead focus
        // on the components with only one infected.

        // We can use BFS to map out all components containing at least
        // one infected (by always starting from an infected node in initial
        // that has not been visited yet).
        // We then check each component and count its size and the number
        // of infected nodes in it. The component with one infected node
        // with the largest size will be the one whose infected node we
        // return. Else removing any node makes no difference so we return
        // 0, the first infected node.

        // First we need to turn our adjacency matrix into a list
        vector<vector<int>> adjList(graph.size());
        for(int i = 0; i < graph.size(); i++){
            for(int j = 0; j < graph.size(); j++){
                if(graph[i][j] && i != j)
                    adjList[i].push_back(j);
            }
        }


        // First we return the connected components with at least
        // one infected in them
        vector<vector<int>> vec = 
            findConnectedComponents(adjList, initial);

        // Then we count each component's number of infected
        int max = 0;        // largest component with 1 infected
        // largest component's infected index
        // Initially the maxIndex is the smallest
        // infected index in case none of the infected cells
        // being removed can benefit us
        int maxIndex = *min_element(initial.begin(), initial.end());
        for(int i = 0; i < vec.size(); i++){
            int count = 0;
            int infectedIndex;
            for(int j = 0; j < vec[i].size(); j++){ 
                for(int k = 0; k < initial.size(); k++){
                    if(initial[k] == vec[i][j]){
                        count++;
                        infectedIndex = initial[k];
                        break;
                    }

                    if(count > 1) break;
                }

                if(count > 1) break;
            }

            // If the component has 1 infected and is larger than
            // the last max component
            if(count == 1){
                if(max < vec[i].size()){
                    max = vec[i].size();
                    maxIndex = infectedIndex;
                }
                // If the size is the same we choose
                // the smaller index
                else if(max == vec[i].size()){
                    maxIndex = min(infectedIndex, maxIndex);
                }
            }
        }

        return maxIndex;
    }
};